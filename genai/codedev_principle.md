# ソフトウェア開発におけるデザイン原則

コード生成をする際は、このドキュメントに記載のデザイン原則に従ってコードを生成すること。
このデザイン原則の目的は、テスト容易性、拡張性、保守性の高いコードを生成することにより、将来にわたって高い品質のソフトウェアを維持し続けられるようにするためである。

MUST のポリシーを違反する場合は、コード変更を実施する前に依頼者へ判断を求めること。

## 一般的なソフトウェア設計ポリシー

1. (MUST) 指示がない場合、ソースコードのコメントや出力は全て英語にしなければならない
2. まず、対象のソフトウェアプロジェクトのイディオム（慣習的パターン）に従う。次に、各プログラミング言語における標準的なイディオム（慣習的パターン）に従う
3. 疎結合、かつ、高凝集なモジュールを重視し、依存関係を明確化・制御する。モジュールは単一責任を実現する
4. できるだけ各プログラミング言語の標準ライブラリを利用することで、外部ライブラリへの依存度を下げる。これにより、脆弱性の対応や外部ライブラリのバージョンアップによる後方互換性の破壊などへの対応を減らす
5. I/O ロジック（CLI、HTTP、ファイルアクセス）と ビジネスロジックを明確に分離する
6. インターフェース（または言語における同等の抽象化手段）を用いて、レイヤーやモジュール間の境界を明確にする
7. インターフェースは宣言的に定義し、「どのように処理するか」ではなく、「何をするか」を表すようにする。これにより、インターフェースの利用者が「何ができるか」を端的に理解できるようにする
8. (MUST) グローバルステートや暗黙的な副作用を禁止する
9. (MUST) クラスやインターフェース間の依存関係は、コンストラクタベースの依存性注入で明示的に示す。これにより、コンストラクタを見ればそのクラスやインターフェースが、どのクラスやインターフェースに依存しているのかを直ちに理解できる
10. ソースコードは責任ごとにディレクトリを整理する（例: usecase, infra, cmd, domain など）ことで、依存関係を明確にし、安定性とモジュール性を実現する
11. (MUST) ソースコードから処理内容がわかるような冗長なコメントは記載しない。また、冗長なコメントを記載せずとも処理内容が分かるような変数名、関数名をつけなければならない
12. (MUST) コメントを記載するのは下記のケースに限定する
    - `// TODO:` のように処理がまだ未実装であることを示す
    - 処理内容が直感的ではないもの
    - 外部仕様に基づく実装の場合
    - 運用などの知見からそうせざるを得なかったもの（Why Not）
13. 変数のスコープはできるだけ小さくする。変数が利用されるスコープの大きさに応じて、変数名の長さを調整する
14. (MUST) 全ての関数には、関数の役割や目的を明確に示すトップレベルコメントを付与すること。コメントは宣言的に記載し、実装の詳細ではなく「何を実現するか」を説明すること
15. (MUST) 対象のソフトウェアプロジェクトですでに利用されている場合を除き、各プログラミング言語で代表的な linter, formatter, testing framework を採用し、CI を通じて常にチェックできるようにすること
16. (MUST) 外部から与えられた入力に対しては validation を実施すること

## 一般的なテスト設計ポリシー

1. (MUST) テストコードは BDD を採用し、各テストケースではどのようなシナリオの際に、どういった振る舞いを期待するのかを定義する。具体的には、`If xxx given, it should yyy` のような形式で記述する
2. 外部接続をするような処理は最小のインターフェースを定義することで、モックやスタブにより代替できるようにする
3. (MUST) テストコード内で繰り返しになるようなテストデータの準備処理は、ヘルパー関数化してテストコードを簡潔にする
4. main 関数から呼び出される関数など、高レベルのエントリ関数のテストコードを優先して実装する。これにより、そのソフトウェアを利用するユーザーが実行するであろうコマンドラインオプションや入力をテストコードで表現でき、わかりやすく、かつ、カバレッジの広い統合テストコードとなる

---

## Go言語でのデザイン原則

### ソフトウェア設計ポリシー

1. (MUST) `context.Context` を必要とする関数では、第一引数に挿入できるようにする。context を活かすため、必ず呼び出し元から受け取り、自分で生成しないこと
2. (MUST) 関数は `(result, error)` または同等の戻り値を持ち、適切にエラーを wrap する。error を wrap せずに返却することを禁止する
3. (MUST) 構造体の初期化はコンストラクタ関数（`NewXxx`）を優先する
4. (MUST) error の wrap には、`fmt.Errorf` を利用する
5. (MUST) panic は main 関数やテスト目的を除いて利用しない。error は必ずハンドリングして、呼び出し元でどう処理すべきかの判断を委ねること
6. (MUST) log は標準ライブラリの `log/slog` を利用する
7. (MUST) `log/slog` のログレベルの使い分けは下記のようにする
    - Error: アプリケーションに致命的な問題が発生しており、このレベルのログが出力されているケースではオペレーターはすぐに対応を行わなければならない
    - Warn: アプリケーションに問題が発生しており、不具合発生時に不具合の原因のヒントとなるもの
    - Info: 統計的な情報などアプリケーションが正常の範囲で稼働していることを示すログ。大量に流れ続けないように注意を払う
    - Debug: デバッグフラグを有効化した時のみ確認できるログ。アプリケーションの詳細の挙動を確認できるログ
8. プロジェクトのディレクトリ構成は、ユースケース駆動の構成を取る（例: cmd/, infra/, usecase/）

### テスト設計ポリシー

1. <https://github.com/cweill/gotests> を利用してテーブル駆動テストを定義する
2. インスタンスの比較は、<https://github.com/google/go-cmp> を利用する
3. <https://github.com/uber-go/mock> で mock を生成する。全てのインターフェースが定義されているファイルには、ファイルの先頭に `//go:generate go run go.uber.org/mock/mockgen -source=$GOFILE -destination=mock_$GOFILE -package=$GOPACKAGE` を記載する。mock はインターフェースの契約テストと組み合わせる
4. 大きなテストデータは、テストファイルではなく testdata フォルダ内に格納し、それをテストコードから読み取る形式にする
